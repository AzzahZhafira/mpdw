---
title: "MPDW 100"
author: "Azzah Zhafira Shidiq"
date: "`r Sys.Date()`"
output: html_document
---

## Library
```{r}
library("forecast")
library("graphics")
library("TTR")
library("TSA")
library(rio)
library(ggplot2)
```

## Import Data
```{r}
data <- import("https://github.com/AzzahZhafira/mpdw/raw/main/Pertemuan%201/Data%20River%20Aire%20Discharge_Azzah%20Zhafira%20Shidiq.xlsx")

head(data)
```

Ambil 100 baris dataset
```{r}
data100 <- data[1:100, ]
```


## Eksplorasi Data

Cek apakah ada data yang hilang
```{r}
data$Date <- as.Date(data$Date)
all_dates <- seq(min(data$Date), max(data$Date), by = "day")
missing_dates <- setdiff(all_dates, data$Date)
missing_dates
```
```{r}
anyNA(data100)
```
Artinya juga data berurutan berdasarkan harinya dan tidak ada missing value.\

Mengubah data agar terbaca sebagai data deret waktu dengan fungsi
```{r}
data100.ts <- ts(data100$Discharge_Armley)
```

Menampilkan ringkasan data
```{r}
summary(data100.ts)
```

Membuat plot data deret waktu
```{r}
ts.plot(data100.ts, xlab="Time Period ", ylab="Discharge", 
        main = "Time Series Plot")
points(data100.ts)
```
Data memiliki lonjakan lonjakan yang tidak stabil sehingga cocok dengan Single Moving Average (SMA), Double Moving Average(DMA) dan Single Exponential Smoothing (SES).

## Single Moving Average & Double Moving Average
### Single Moving Average (SMA)
#### Pembagian Data
Pembagian data latih dan data uji dilakukan dengan perbandingan 80% data latih dan 20% data uji.

```{r}
# Membagi data latih dan data uji
training_ma <- data100[1:80,]
testing_ma <- data100[81:100,]
train_ma.ts <- ts(training_ma$Discharge_Armley)
test_ma.ts <- ts(testing_ma$Discharge_Armley)
```

#### Plot

```{r}
# eksplorasi data
plot(data100.ts, col="red",main="Plot semua data")
points(data100.ts)

# eksplorasi data latih
plot(train_ma.ts, col="blue",main="Plot data latih")
points(train_ma.ts)

# eksplorasi data uji
plot(test_ma.ts, col="blue",main="Plot data uji")
points(test_ma.ts)
```


```{r}
# Eksplorasi dengan GGPLOT
library(ggplot2)
ggplot() + 
  geom_line(data = training_ma, aes(x = Date, y = Discharge_Armley, col = "Data Latih")) +
  geom_line(data = testing_ma, aes(x = Date, y = Discharge_Armley, col = "Data Uji")) +
  labs(x = "Periode Waktu", y = "Debit Aliran Sungai", color = "Legend") +
  scale_colour_manual(name="Keterangan:", breaks = c("Data Latih", "Data Uji"),
                      values = c("blue", "red")) + 
  theme_bw() + theme(legend.position = "bottom",
                     plot.caption = element_text(hjust=0.5, size=12))
```


```{r}
data.sma <- SMA(train_ma.ts, n=4)
data.sma
```

```{r}
data.ramal <- c(NA,data.sma)
data.ramal #forecast 1 periode ke depan
```
Selanjutnya akan dilakukan peramalan sejumlah data uji yaitu 24 periode. Pada metode SMA, hasil peramalan 24 periode ke depan akan bernilai sama dengan hasil peramalan 1 periode kedepan. Dalam hal ini akan dilakukan pengguabungan data aktual train, data hasil pemulusan dan data hasil ramalan 24 periode kedepan.

```{r}
data.gab <- cbind(
  aktual=c(train_ma.ts,rep(NA,24)),
  pemulusan=c(data.sma,rep(NA,24)),
  ramalan=c(data.ramal,rep(data.ramal[length(data.ramal)],23)))

data.gab 
```

Adapun plot data deret waktu dari hasil peramalan yang dilakukan adalah sebagai berikut.

```{r}
ts.plot(data100.ts, xlab="Date ", ylab="Discharge", main= "SMA N=2 Data Discharge")
points(data100.ts)
lines(data.gab[,2],col="green",lwd=2)
lines(data.gab[,3],col="red",lwd=2)
legend("topleft",c("data aktual","data pemulusan","data peramalan"), lty=8, col=c("black","green","red"), cex=0.5)
```

Selanjutnya perhitungan akurasi dilakukan dengan ukuran akurasi *Sum Squares Error* (SSE), *Mean Square Error* (MSE) dan *Mean Absolute Percentage Error* (MAPE). Perhitungan akurasi dilakukan baik pada data latih maupun pada data uji.

```{r}
#Menghitung nilai keakuratan data latih
error_train.sma = train_ma.ts-data.ramal[1:length(train_ma.ts)]

SSE_train.sma = sum(error_train.sma[5:length(train_ma.ts)]^2)
MSE_train.sma = mean(error_train.sma[5:length(train_ma.ts)]^2)
MAPE_train.sma = mean(abs((error_train.sma[5:length(train_ma.ts)]/train_ma.ts[5:length(train_ma.ts)])*100))

akurasi_train.sma <- matrix(c(SSE_train.sma, MSE_train.sma, MAPE_train.sma))
row.names(akurasi_train.sma)<- c("SSE", "MSE", "MAPE")
colnames(akurasi_train.sma) <- c("Akurasi m = 4")
akurasi_train.sma
```
Dalam hal ini nilai MAPE data latih pada metode pemulusan SMA lebih dari 30%, nilai ini dapat dikategorikan sebagai nilai akurasi yang tidak cukup baik. Selanjutnya dilakukan perhitungan nilai MAPE data uji pada metode pemulusan SMA.

```{r}
#Menghitung nilai keakuratan data uji
error_test.sma = test_ma.ts-data.gab[81:100,3]
SSE_test.sma = sum(error_test.sma^2)
MSE_test.sma = mean(error_test.sma^2)
MAPE_test.sma = mean(abs((error_test.sma/test_ma.ts*100)))

akurasi_test.sma <- matrix(c(SSE_test.sma, MSE_test.sma, MAPE_test.sma))
row.names(akurasi_test.sma)<- c("SSE", "MSE", "MAPE")
colnames(akurasi_test.sma) <- c("Akurasi m = 4")
akurasi_test.sma
```
Perhitungan akurasi menggunakan data latih menghasilkan nilai MAPE yang lebih dari 30% sehingga nilai akurasi ini dapat dikategorikan sebagai nilai akurasi yang tidak cukup baik.

### Double Moving Average (DMA)

Metode pemulusan Double Moving Average (DMA) pada dasarnya mirip dengan SMA. Namun demikian, metode ini lebih cocok digunakan untuk pola data trend. Proses pemulusan dengan rata rata dalam metode ini dilakukan sebanyak 2 kali.

```{r}
dma <- SMA(data.sma, n = 2)
At <- 2*data.sma - dma
Bt <- 2/(4-1)*(data.sma - dma)
data.dma<- At+Bt
data.ramal2<- c(NA, data.dma)

t = 1:22
f = c()

for (i in t) {
  f[i] = At[length(At)] + Bt[length(Bt)]*(i)
}

data.gab2 <- cbind(aktual = c(train_ma.ts,rep(NA,22)), pemulusan1 = c(data.sma,rep(NA,22)),pemulusan2 = c(data.dma, rep(NA,22)),At = c(At, rep(NA,22)), Bt = c(Bt,rep(NA,22)),ramalan = c(data.ramal2, f[-1]))
data.gab2

```

Hasil pemulusan menggunakan metode DMA divisualisasikan sebagai berikut.

```{r}
ts.plot(data100.ts, xlab="Time Period ", ylab="Sales", main= "DMA N=2 Data Sales")
points(data100.ts)
lines(data.gab2[,3],col="green",lwd=2)
lines(data.gab2[,6],col="red",lwd=2)
legend("topleft",c("data aktual","data pemulusan","data peramalan"), lty=8, col=c("black","green","red"), cex=0.8)

```

Selanjutnya perhitungan akurasi dilakukan baik pada data latih maupun data uji. Perhitungan akurasi dilakukan dengan ukuran akurasi SSE, MSE dan MAPE.

```{r}
#Menghitung nilai keakuratan data latih
error_train.dma = train_ma.ts-data.ramal2[1:length(train_ma.ts)]
SSE_train.dma = sum(error_train.dma[6:length(train_ma.ts)]^2)
MSE_train.dma = mean(error_train.dma[6:length(train_ma.ts)]^2)
MAPE_train.dma = mean(abs((error_train.dma[6:length(train_ma.ts)]/train_ma.ts[6:length(train_ma.ts)])*100))

akurasi_train.dma <- matrix(c(SSE_train.dma, MSE_train.dma, MAPE_train.dma))
row.names(akurasi_train.dma)<- c("SSE", "MSE", "MAPE")
colnames(akurasi_train.dma) <- c("Akurasi m = 2")
akurasi_train.dma
```

Perhitungan akurasi pada data latih menggunakan nilai MAPE menghasilkan nilai MAPE yang lebih dari 30% sehingga dikategorikan tidak cukup baik. Selanjutnya, perhitungan nilai akurasi dilakukan pada data uji.

```{r}
#Menghitung nilai keakuratan data uji
error_test.dma = test_ma.ts-data.gab2[81:100,6]
SSE_test.dma = sum(error_test.dma^2)
MSE_test.dma = mean(error_test.dma^2)
MAPE_test.dma = mean(abs((error_test.dma/test_ma.ts*100)))

akurasi_test.dma <- matrix(c(SSE_test.dma, MSE_test.dma, MAPE_test.dma))
row.names(akurasi_test.dma)<- c("SSE", "MSE", "MAPE")
colnames(akurasi_test.dma) <- c("Akurasi m = 4")
akurasi_test.dma
```
Perhitungan akurasi menggunakan data latih menghasilkan nilai MAPE yang lebih dari 30% sehingga nilai akurasi ini dapat dikategorikan sebagai nilai akurasi yang tidak cukup baik.

Pada data latih, metode DMA lebih baik dibandingkan dengan metode SMA, sedangkan pada data uji, metode SMA lebih baik dibandingkan DMA.

## Single Exponential Smoothing & Double Exponential Smoothing

Metode *Exponential Smoothing* adalah metode pemulusan dengan melakukan pembobotan menurun secara eksponensial. Nilai yang lebih baru diberi bobot yang lebih besar dari nilai terdahulu. Terdapat satu atau lebih parameter pemulusan yang ditentukan secara eksplisit, dan hasil pemilihan parameter tersebut akan menentukan bobot yang akan diberikan pada nilai pengamatan. Ada dua macam model, yaitu model tunggal dan ganda.

### SES

Single Exponential Smoothing merupakan metode pemulusan yang tepat digunakan untuk data dengan pola stasioner atau konstan.

#### Pembagian Data
Pembagian data latih dan data uji dilakukan dengan perbandingan 80% data latih dan 20% data uji.

```{r}
# Membagi data latih dan data uji
training <- data100[1:80,]
testing <- data100[81:100,]
train.ts <- ts(training_ma$Discharge_Armley)
test.ts <- ts(testing_ma$Discharge_Armley)
```

```{r}
# Cara 1 (fungsi ses)
ses.1 <- ses(train.ts, h = 20, alpha = 0.3)
plot(ses.1)
ses.1

ses.2<- ses(train.ts, h = 20, alpha = 0.8)
plot(ses.2)
ses.2
```


```{r}
autoplot(ses.1) +
  autolayer(fitted(ses.1), series="Fitted") +
  ylab("Discharge") + xlab("Date")
```


```{r}
# Cara 2 (fungsi Holtwinter)
ses1 <- HoltWinters(train.ts, gamma = FALSE, beta = FALSE, alpha = 0.3)
plot(ses1)

#ramalan
ramalan1 <- forecast(ses1, h = 20)
ramalan1

ses2 <- HoltWinters(train.ts, gamma = FALSE, beta = FALSE, alpha = 0.8)
plot(ses2)

#ramalan
ramalan2<- forecast(ses2, h = 20)
ramalan2
```

Nilai parameter $\alpha$ dari kedua fungsi dapat dioptimalkan menyesuaikan dari *error*-nya paling minimumnya. Caranya adalah dengan membuat parameter $\alpha =$ `NULL` .

```{r}
#SES
ses.opt <- ses(train.ts, h = 20, alpha = NULL)
plot(ses.opt)
ses.opt

#Lamda Optimum Holt Winter
sesopt <- HoltWinters(train.ts, gamma = FALSE, beta = FALSE,alpha = NULL)
sesopt
plot(sesopt)

#ramalan
ramalanopt<- forecast(sesopt, h = 20)
ramalanopt
```

Setelah dilakukan peramalan, akan dilakukan perhitungan keakuratan hasil peramalan. Perhitungan akurasi ini dilakukan baik pada data latih dan data uji.

#### Akurasi Data Latih

```{r}
#Keakuratan Metode
#Pada data training

# SES dengan alpha = 0.3
SSE1<-ses1$SSE
MSE1<-ses1$SSE/length(train.ts)
RMSE1<-sqrt(MSE1)

akurasi1 <- matrix(c(SSE1,MSE1,RMSE1))
row.names(akurasi1)<- c("SSE", "MSE", "RMSE")
colnames(akurasi1) <- c("Akurasi lamda = 0.3")
akurasi1
```

```{r}
# SES dengan alpha = 0.8
SSE2<-ses2$SSE
MSE2<-ses2$SSE/length(train.ts)
RMSE2<-sqrt(MSE2)

akurasi2 <- matrix(c(SSE2,MSE2,RMSE2))
row.names(akurasi2)<- c("SSE", "MSE", "RMSE")
colnames(akurasi2) <- c("Akurasi lamda = 0.8")
akurasi2
```

```{r}
# SES dengan alpha = optimum
SSE_opt<-sesopt$SSE
MSE_opt<-sesopt$SSE/length(train.ts)
RMSE_opt<-sqrt(MSE_opt)

akurasi_opt <- matrix(c(SSE_opt,MSE_opt,RMSE_opt))
row.names(akurasi_opt)<- c("SSE", "MSE", "RMSE")
colnames(akurasi_opt) <- c("Akurasi lamda = optimum")
akurasi_opt
```
**Hasil Data Training:** Dari data training diperoleh bahwa **nilai SSE, MSE, dan RMSE pada alpha optimum < alpha = 0.8 < alpha = 0.3**. Artinya Model dengan alpha optimum lebih baik dibandingkan dengan alpha 0.8 dan alpha 0.2. Dan model dengan alpha 0.8 lebih baik dari pada model dengan alpha 0.2

#### Akurasi Data Uji

Akurasi data uji dapat dihitung dengan cara yang hampir sama dengan perhitungan akurasi data latih.

```{r}
selisih1    <- ramalan1$mean - testing$Discharge_Armley
SSEtesting1 <- sum(selisih1^2)
MSEtesting1 <- SSEtesting1/length(testing)
RMSEtesting1 <- sqrt(MSEtesting1)

selisih2    <- ramalan2$mean - testing$Discharge_Armley
SSEtesting2 <- sum(selisih2^2)
MSEtesting2 <- SSEtesting2/length(testing)
RMSEtesting2 <- sqrt(MSEtesting2)

selisihopt    <- ramalanopt$mean - testing$Discharge_Armley
SSEtestingopt <- sum(selisihopt^2)
MSEtestingopt <- SSEtestingopt/length(testing)
RMSEtestingopt <- sqrt(MSEtestingopt)

# Tabel Ringkas (SSE, MSE, RMSE)
akurasitesting_SSE <- matrix(c(SSEtesting1,SSEtesting2,SSEtestingopt))
row.names(akurasitesting_SSE)<- c("SSE1", "SSE2", "SSEopt")

akurasitesting_MSE <- matrix(c(MSEtesting1,MSEtesting2,MSEtestingopt))
row.names(akurasitesting_MSE)<- c("MSE1", "MSE2", "MSEopt")

akurasitesting_RMSE <- matrix(c(RMSEtesting1,RMSEtesting2,RMSEtestingopt))
row.names(akurasitesting_RMSE)<- c("RMSE1", "RMSE2", "RMSEopt")

```

```{r}
akurasitesting_SSE
```
Berdasarkan nilai SSE diatas pada data testing didapat hasil bahwa **SSE1 > SSE2 > SSEopt**, artinya model dengan alpha optimum lebih baik dari pada model dengan alpha0.8 dan 0.2.

```{r}
akurasitesting_MSE
```
Berdasarkan nilai MSE diatas pada data testing didapat hasil bahwa **MSE1 > MSE2 > MSEopt**, artinya model dengan alpha optimum lebih baik dari pada model dengan alpha 0.8 dan 0.2.


```{r}
akurasitesting_RMSE
```
Berdasarkan nilai RMSE diatas pada data testing didapat hasil bahwa **RMSE1 > RMSE2 > RMSEopt**, artinya model dengan alpha optimum lebih baik dari pada model dengan alpha 0.8 dan 0.2.

```{r}
#cara lain
accuracy(ramalan1,testing$Discharge_Armley)
accuracy(ramalan2,testing$Discharge_Armley)
accuracy(ramalanopt,testing$Discharge_Armley)
```
Berdasarkan nilai RMSE diatas pada data testing didapat hasil bahwa **MAPE1 > MAPE2 > MAPEopt**. Hal ini menunjukkan bahwa model dengan α optimum memberikan hasil yang lebih baik dibandingkan dengan model α = 0.8 maupun α = 0.2. Namun, nilai MAPE pada α optimum untuk data testing masih lebih dari 30%, sehingga model tersebut dapat dikatakan belum cukup baik.
